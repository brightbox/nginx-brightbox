<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Passenger: Passenger::SpawnManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacePassenger.html">Passenger</a>::<a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a>
  </div>
</div>
<div class="contents">
<h1>Passenger::SpawnManager Class Reference<br>
<small>
[<a class="el" href="group__Support.html">Apache-independent support classes and function</a>]</small>
</h1><!-- doxytag: class="Passenger::SpawnManager" --><!-- doxytag: inherits="Passenger::AbstractSpawnManager" -->An <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> implementation.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="SpawnManager_8h-source.html">SpawnManager.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Passenger::SpawnManager:</div>
<div class="dynsection">
<p><center><img src="classPassenger_1_1SpawnManager__inherit__graph.png" border="0" usemap="#Passenger_1_1SpawnManager__inherit__map" alt="Inheritance graph"></center>
<map name="Passenger_1_1SpawnManager__inherit__map">
<area shape="rect" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes." alt="" coords="6,5,246,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPassenger_1_1SpawnManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#9dcfe537ec598125fc83a1625ba50552">SpawnManager</a> (const string &amp;spawnServerCommand, const ServerInstanceDir::GenerationPtr &amp;generation, const AccountsDatabasePtr &amp;accountsDatabase=AccountsDatabasePtr(), const string &amp;rubyCommand=&quot;ruby&quot;, const AnalyticsLoggerPtr &amp;analyticsLogger=AnalyticsLoggerPtr())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a>.  <a href="#9dcfe537ec598125fc83a1625ba50552"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespacePassenger.html#ced1f248465136b313c6dec5fe6ca492">ProcessPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#88a94ba4d41dab492cb1dc8a0f998973">spawn</a> (const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn a new application process.  <a href="#88a94ba4d41dab492cb1dc8a0f998973"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#ad71b2ea9431f3286f23a6e6f80e0981">reload</a> (const string &amp;appRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the ApplicationSpawner server that's running at the given application root.  <a href="#ad71b2ea9431f3286f23a6e6f80e0981"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#9210212c23c5a8ee5ee4dd5c9dcdf57d">killSpawnServer</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forcefully kill the spawn server.  <a href="#9210212c23c5a8ee5ee4dd5c9dcdf57d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#f34df8cfccfc64507999f1b48bc5a126">getServerPid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the spawn server's PID.  <a href="#f34df8cfccfc64507999f1b48bc5a126"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#b4dfcb11c58b07d8144b18dd99abed45">spawnServerStarted</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A method which is called after the spawn server has started.  <a href="#b4dfcb11c58b07d8144b18dd99abed45"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
An <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> implementation. 
<p>
Internally, this class makes use of a spawn server, which is written in Ruby. This server is automatically started when a <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> instance is created, and automatically shutdown when that instance is destroyed. The existance of the spawn server is almost totally transparent to users of this class. Spawn requests are sent to the server, and details about the spawned process is returned.<p>
If the spawn server dies during the middle of an operation, it will be restarted. See <a class="el" href="classPassenger_1_1SpawnManager.html#88a94ba4d41dab492cb1dc8a0f998973" title="Spawn a new application process.">spawn()</a> for full details.<p>
The communication channel with the server is anonymous, i.e. no other processes can access the communication channel, so communication is guaranteed to be safe (unless, of course, if the spawn server itself is a trojan).<p>
The server will try to keep the spawning time as small as possible, by keeping corresponding Ruby on Rails frameworks and application code in memory. So the second time a process of the same application is spawned, the spawn time is significantly lower than the first time. Nevertheless, spawning is a relatively expensive operation (compared to the processing of a typical HTTP request/response), and so should be avoided whenever possible.<p>
See the documentation of the spawn server for full implementation details. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9dcfe537ec598125fc83a1625ba50552"></a><!-- doxytag: member="Passenger::SpawnManager::SpawnManager" ref="9dcfe537ec598125fc83a1625ba50552" args="(const string &amp;spawnServerCommand, const ServerInstanceDir::GenerationPtr &amp;generation, const AccountsDatabasePtr &amp;accountsDatabase=AccountsDatabasePtr(), const string &amp;rubyCommand=&quot;ruby&quot;, const AnalyticsLoggerPtr &amp;analyticsLogger=AnalyticsLoggerPtr())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Passenger::SpawnManager::SpawnManager           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>spawnServerCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ServerInstanceDir::GenerationPtr &amp;&nbsp;</td>
          <td class="paramname"> <em>generation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccountsDatabasePtr &amp;&nbsp;</td>
          <td class="paramname"> <em>accountsDatabase</em> = <code>AccountsDatabasePtr()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>rubyCommand</em> = <code>&quot;ruby&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnalyticsLoggerPtr &amp;&nbsp;</td>
          <td class="paramname"> <em>analyticsLogger</em> = <code>AnalyticsLoggerPtr()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spawnServerCommand</em>&nbsp;</td><td>The filename of the spawn server to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>generation</em>&nbsp;</td><td>The server instance dir generation in which generation-specific are stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accountsDatabase</em>&nbsp;</td><td>An accounts database. <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> will automatically create a new account for each spawned process, assigning it the rights as set in the <a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a> object. This account is also automatically deleted when no longer needed. May be a null pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rubyCommand</em>&nbsp;</td><td>The Ruby interpreter's command. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1RuntimeException.html" title="A generic runtime exception.">RuntimeException</a></em>&nbsp;</td><td>An error occurred while creating a Unix server socket. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>An error occured while trying to setup the spawn server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1IOException.html" title="Represents an error that occured during an I/O operation.">IOException</a></em>&nbsp;</td><td>An error occurred while generating random data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="f34df8cfccfc64507999f1b48bc5a126"></a><!-- doxytag: member="Passenger::SpawnManager::getServerPid" ref="f34df8cfccfc64507999f1b48bc5a126" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pid_t Passenger::SpawnManager::getServerPid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the spawn server's PID. 
<p>
Used within unit tests. 
<p>Implements <a class="el" href="classPassenger_1_1AbstractSpawnManager.html#a630e8c364f391b54c0bfb723326836a">Passenger::AbstractSpawnManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="9210212c23c5a8ee5ee4dd5c9dcdf57d"></a><!-- doxytag: member="Passenger::SpawnManager::killSpawnServer" ref="9210212c23c5a8ee5ee4dd5c9dcdf57d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::SpawnManager::killSpawnServer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forcefully kill the spawn server. 
<p>
This AbstractSpawnManager's state will not be modified, so that it won't know that the spawn server is killed until next time it sends a command to it.<p>
Used within unit tests. 
<p>Implements <a class="el" href="classPassenger_1_1AbstractSpawnManager.html#225574ef363847058554fde9d5704950">Passenger::AbstractSpawnManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="ad71b2ea9431f3286f23a6e6f80e0981"></a><!-- doxytag: member="Passenger::SpawnManager::reload" ref="ad71b2ea9431f3286f23a6e6f80e0981" args="(const string &amp;appRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::SpawnManager::reload           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>appRoot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shutdown the ApplicationSpawner server that's running at the given application root. 
<p>
This method should be called when it's time to reload an application.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>Unable to communicate with the spawn server, even after a restart. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SpawnException.html" title="Thrown when SpawnManager or ApplicationPool fails to spawn an application instance...">SpawnException</a></em>&nbsp;</td><td>The spawn server died unexpectedly, and a restart was attempted, but it failed. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classPassenger_1_1AbstractSpawnManager.html#5043681dbfb9b77fa0679c510ede853c">Passenger::AbstractSpawnManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="88a94ba4d41dab492cb1dc8a0f998973"></a><!-- doxytag: member="Passenger::SpawnManager::spawn" ref="88a94ba4d41dab492cb1dc8a0f998973" args="(const PoolOptions &amp;options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacePassenger.html#ced1f248465136b313c6dec5fe6ca492">ProcessPtr</a> Passenger::SpawnManager::spawn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawn a new application process. 
<p>
Spawning details are to be passed via the <code>options</code> argument.<p>
If the spawn server died during the spawning process, then the server will be automatically restarted, and another spawn attempt will be made. If restarting the server fails, or if the second spawn attempt fails, then an exception will be thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>An object containing the details for this spawn operation, such as which application to spawn. See <a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a> for details. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to a <a class="el" href="classPassenger_1_1Process.html" title="Represents a single application process, as spawned by SpawnManager or by ApplicationPool::Interface...">Process</a> object, which represents the application process that has been spawned. Use this object to communicate with the spawned process. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SpawnException.html" title="Thrown when SpawnManager or ApplicationPool fails to spawn an application instance...">SpawnException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boost::thread_interrupted</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Anything</em>&nbsp;</td><td>thrown by options.environmentVariables-&gt;getItems(). </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classPassenger_1_1AbstractSpawnManager.html#6ca7efc68595bf962f5cce5e6407f176">Passenger::AbstractSpawnManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="b4dfcb11c58b07d8144b18dd99abed45"></a><!-- doxytag: member="Passenger::SpawnManager::spawnServerStarted" ref="b4dfcb11c58b07d8144b18dd99abed45" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::SpawnManager::spawnServerStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A method which is called after the spawn server has started. 
<p>
It doesn't do anything by default and serves as a hook for unit tests. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SpawnManager_8h-source.html">SpawnManager.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Mar 28 14:11:59 2010 for Passenger by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
