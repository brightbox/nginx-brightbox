<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Passenger: Passenger Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Passenger Namespace Reference</h1>This file provides a bunch of classes for reading and writing messages in the <a class="el" href="classPassenger_1_1MessageChannel.html" title="Convenience class for I/O operations on file descriptors.">MessageChannel</a> format.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1DirectoryMapper.html">DirectoryMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class for determining URI-to-application directory mappings.  <a href="classPassenger_1_1DirectoryMapper.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawning of application processes.  <a href="classPassenger_1_1AbstractSpawnManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SystemException.html">SystemException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an error returned by a system call or a standard library call.  <a href="classPassenger_1_1SystemException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileSystemException.html">FileSystemException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A filesystem error, as returned by the operating system.  <a href="classPassenger_1_1FileSystemException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1TimeRetrievalException.html">TimeRetrievalException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unable to retrieve the system time using <code>time()</code>.  <a href="classPassenger_1_1TimeRetrievalException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1IOException.html">IOException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an error that occured during an I/O operation.  <a href="classPassenger_1_1IOException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileNotFoundException.html">FileNotFoundException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when a certain file cannot be found.  <a href="classPassenger_1_1FileNotFoundException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EOFException.html">EOFException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unexpected end-of-file I/O error.  <a href="classPassenger_1_1EOFException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ConfigurationException.html">ConfigurationException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when an invalid configuration is given.  <a href="classPassenger_1_1ConfigurationException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnException.html">SpawnException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown when <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> or ApplicationPool fails to spawn an application instance.  <a href="classPassenger_1_1SpawnException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ArgumentException.html">ArgumentException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates that a specified argument is incorrect or violates a requirement.  <a href="classPassenger_1_1ArgumentException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1RuntimeException.html">RuntimeException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic runtime exception.  <a href="classPassenger_1_1RuntimeException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1TimeoutException.html">TimeoutException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception indicating that some timeout expired.  <a href="classPassenger_1_1TimeoutException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SecurityException.html">SecurityException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents some kind of security error.  <a href="classPassenger_1_1SecurityException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1BusyException.html">BusyException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The application pool is too busy and cannot fulfill a get() request.  <a href="classPassenger_1_1BusyException.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class around a file descriptor integer, for RAII behavior.  <a href="classPassenger_1_1FileDescriptor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1EventFd.html">EventFd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A synchronization mechanism that's implemented with file descriptors, and as such can be used in combination with select() and friends.  <a href="classPassenger_1_1EventFd.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience class for I/O operations on file descriptors.  <a href="classPassenger_1_1MessageChannel.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Uint16Reader.html">Uint16Reader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a 16-bit big-endian integer.  <a href="classPassenger_1_1Uint16Reader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Uint32Reader.html">Uint32Reader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a 32-bit big-endian integer.  <a href="classPassenger_1_1Uint32Reader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ArrayReader.html">ArrayReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a an array message.  <a href="classPassenger_1_1ArrayReader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScalarReader.html">ScalarReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for reading a scalar message.  <a href="classPassenger_1_1ScalarReader.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1MessageServer.html">MessageServer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple pluggable request/response messaging server framework.  <a href="classPassenger_1_1MessageServer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This struct encapsulates information for ApplicationPool::get() and for <a class="el" href="classPassenger_1_1SpawnManager.html#88a94ba4d41dab492cb1dc8a0f998973" title="Spawn a new application process.">SpawnManager::spawn()</a>, such as which application is to be spawned.  <a href="structPassenger_1_1PoolOptions.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Process.html">Process</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single application process, as spawned by <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> or by ApplicationPool::Interface::get().  <a href="classPassenger_1_1Process.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1RandomGenerator.html">RandomGenerator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A random data generator.  <a href="classPassenger_1_1RandomGenerator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1Session.html">Session</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single request/response pair of an application process.  <a href="classPassenger_1_1Session.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1StandardSession.html">StandardSession</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A "standard" implementation of <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a>.  <a href="classPassenger_1_1StandardSession.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> implementation.  <a href="classPassenger_1_1SpawnManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1StaticString.html">StaticString</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An immutable, static byte buffer.  <a href="classPassenger_1_1StaticString.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPassenger_1_1AnythingToString.html">AnythingToString</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used internally by <a class="el" href="group__Support.html#gf6fab368d70c18fdf16bf5a24f630407" title="Convert anything to a string.">toString()</a>.  <a href="structPassenger_1_1AnythingToString.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPassenger_1_1AnythingToString_3_01vector_3_01string_01_4_01_4.html">AnythingToString&lt; vector&lt; string &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used internally by <a class="el" href="group__Support.html#gf6fab368d70c18fdf16bf5a24f630407" title="Convert anything to a string.">toString()</a>.  <a href="structPassenger_1_1AnythingToString_3_01vector_3_01string_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPassenger_1_1AnythingToString_3_01vector_3_01StaticString_01_4_01_4.html">AnythingToString&lt; vector&lt; StaticString &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used internally by <a class="el" href="group__Support.html#gf6fab368d70c18fdf16bf5a24f630407" title="Convert anything to a string.">toString()</a>.  <a href="structPassenger_1_1AnythingToString_3_01vector_3_01StaticString_01_4_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1BufferedUpload.html">BufferedUpload</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a buffered upload file.  <a href="classPassenger_1_1BufferedUpload.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1MemZeroGuard.html">MemZeroGuard</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the given memory space or string with zeroes when a MemoryZeroGuard object is destroyed.  <a href="classPassenger_1_1MemZeroGuard.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1HttpStatusExtractor.html">HttpStatusExtractor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class for extracting the HTTP status value from an HTTP response.  <a href="classPassenger_1_1HttpStatusExtractor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ScgiRequestParser.html">ScgiRequestParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parser for SCGI requests.  <a href="classPassenger_1_1ScgiRequestParser.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef shared_ptr<br class="typebreak">
&lt; <a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#fd60d942a89fbb7f306e330d75704570">AbstractSpawnManagerPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> smart pointer.  <a href="#fd60d942a89fbb7f306e330d75704570"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef shared_ptr&lt; <a class="el" href="classPassenger_1_1Process.html">Process</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#ced1f248465136b313c6dec5fe6ca492">ProcessPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1Process.html" title="Represents a single application process, as spawned by SpawnManager or by ApplicationPool::Interface...">Process</a> smart pointer.  <a href="#ced1f248465136b313c6dec5fe6ca492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef shared_ptr&lt; <a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#6ab2d566ff87a2676c23d8aa40204587">SpawnManagerPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenient alias for <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> smart pointer.  <a href="#6ab2d566ff87a2676c23d8aa40204587"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d">FileType</a> { <a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d9fc66834fe96c52799397496b8df8486">FT_NONEXISTANT</a>, 
<a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d1538596a928321d1a282c6bb06e80563">FT_REGULAR</a>, 
<a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07dbb09dbba1071b4770913363db2462eee">FT_DIRECTORY</a>, 
<a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d3e89b9a7be074975e007d9f7cd77f4ff">FT_OTHER</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration which indicates what kind of file a file is.  <a href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">apr_bucket *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#35b11c8ce90e90d01380f182d82f8cac">passenger_bucket_create</a> (SessionPtr session, PassengerBucketStatePtr state, apr_bucket_alloc_t *list)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We used to use an apr_bucket_pipe for forwarding the backend process's response to the HTTP client.  <a href="#35b11c8ce90e90d01380f182d82f8cac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g73b17b509ee44938a56bf16cbf82fb48"></a><!-- doxytag: member="Passenger::atoi" ref="g73b17b509ee44938a56bf16cbf82fb48" args="(const string &amp;s)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g73b17b509ee44938a56bf16cbf82fb48">atoi</a> (const string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the given string to an integer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7b50461f1bc2b370c956967870da2762"></a><!-- doxytag: member="Passenger::atol" ref="g7b50461f1bc2b370c956967870da2762" args="(const string &amp;s)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g7b50461f1bc2b370c956967870da2762">atol</a> (const string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the given string to a long integer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g4b8320aedc6a164a535c920234e3d8bf">split</a> (const string &amp;str, char sep, vector&lt; string &gt; &amp;output)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split the given string using the given separator.  <a href="group__Support.html#g4b8320aedc6a164a535c920234e3d8bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g2a62e38a72c6c65992e3361f6d80c7ef">fileExists</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;filename, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified file exists.  <a href="group__Support.html#g2a62e38a72c6c65992e3361f6d80c7ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d">FileType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g15298b031377d3ecb80295bd5b1a8180">getFileType</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;filename, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether 'filename' exists and what kind of file it is.  <a href="group__Support.html#g15298b031377d3ecb80295bd5b1a8180"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g6f414070373465da2e12947463f69953">createFile</a> (const string &amp;filename, const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;contents, mode_t permissions=S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN, bool overwrite=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the given file with the given contents, permissions and ownership.  <a href="group__Support.html#g6f414070373465da2e12947463f69953"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gf3b0a483f0a252ae08d9de9f8b267d36">canonicalizePath</a> (const string &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a canonical version of the specified path.  <a href="group__Support.html#gf3b0a483f0a252ae08d9de9f8b267d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gc3d2b3d608188527d888e63d22c5163c">resolveSymlink</a> (const string &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <em>path</em> refers to a symlink, then this function resolves the symlink for 1 level.  <a href="group__Support.html#gc3d2b3d608188527d888e63d22c5163c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge651ece5281f22dc5fc974079f7c9187"></a><!-- doxytag: member="Passenger::extractDirName" ref="ge651ece5281f22dc5fc974079f7c9187" args="(const StaticString &amp;path)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ge651ece5281f22dc5fc974079f7c9187">extractDirName</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path, extracts its directory name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="geb750234207485fa57609174ca8d4359"></a><!-- doxytag: member="Passenger::extractBaseName" ref="geb750234207485fa57609174ca8d4359" args="(const StaticString &amp;path)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#geb750234207485fa57609174ca8d4359">extractBaseName</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a path, extracts its base name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#ge74addedf73782a1eb1f6dd48d6fce06">escapeForXml</a> (const string &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Escape the given raw string into an XML value.  <a href="group__Support.html#ge74addedf73782a1eb1f6dd48d6fce06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g7e3fdc923bdf6efeab407cdd325883a8">setNonBlocking</a> (int fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a socket in non-blocking mode.  <a href="group__Support.html#g7e3fdc923bdf6efeab407cdd325883a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#de80218e8b836b796f8b960b6225b439">getProcessUsername</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the username of the user that the current process is running as.  <a href="#de80218e8b836b796f8b960b6225b439"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">mode_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#da53f5a9bdcf3d22d4a710e7ea3678e9">parseModeString</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a mode string into a mode_t value.  <a href="#da53f5a9bdcf3d22d4a710e7ea3678e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g68f4105c5a8e510520b5ea3eecb66213">getSystemTempDir</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the path name for the directory in which the system stores general temporary files.  <a href="group__Support.html#g68f4105c5a8e510520b5ea3eecb66213"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#448f25263af0b37b91caee3d294ec4aa">makeDirTree</a> (const string &amp;path, const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;mode=&quot;u=rwx,g=,o=&quot;, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the directory at the given path, creating intermediate directories if necessary.  <a href="#448f25263af0b37b91caee3d294ec4aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#8422d210cbd2f62d21254415b5a7f747">removeDirTree</a> (const string &amp;path)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entire directory tree recursively.  <a href="#8422d210cbd2f62d21254415b5a7f747"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g5e6bc7ff22b7c61238d7913521936f71">verifyRailsDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid Ruby on Rails application root directory.  <a href="group__Support.html#g5e6bc7ff22b7c61238d7913521936f71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g53969f8e3ee68d1d99ffe75af8db9be8">verifyRackDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid Rack application root directory.  <a href="group__Support.html#g53969f8e3ee68d1d99ffe75af8db9be8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gaec51d2912999d611994c49341f36247">verifyWSGIDir</a> (const string &amp;dir, CachedFileStat *cstat=0, unsigned int throttleRate=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the specified directory is a valid WSGI application root directory.  <a href="group__Support.html#gaec51d2912999d611994c49341f36247"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#1d0a66b0e207c46dc6124ff3b2f331e6">getHostName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the system's host name.  <a href="#1d0a66b0e207c46dc6124ff3b2f331e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#d88884ee6e2184ef8656fc20f0549b0b">fillInMiddle</a> (unsigned int max, const string &amp;prefix, const string &amp;middle, const string &amp;postfix=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a prefix string, a middle string and a postfix string, try to build a string that looks like <code>prefix + middle + postfix</code>, with as many characters from <code>midle</code> preserved as possible.  <a href="#d88884ee6e2184ef8656fc20f0549b0b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d4b16a419fe7231bc8b7036266f8131"></a><!-- doxytag: member="Passenger::toHex" ref="1d4b16a419fe7231bc8b7036266f8131" args="(const StaticString &amp;data)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#1d4b16a419fe7231bc8b7036266f8131">toHex</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given binary data to hexadecimal. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#8b73dbe534ee6daf755909cf6c321166">toHex</a> (const <a class="el" href="classPassenger_1_1StaticString.html">StaticString</a> &amp;data, char *output)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given binary data to hexadecimal.  <a href="#8b73dbe534ee6daf755909cf6c321166"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="979cb43cef743bf261c329b13e712366"></a><!-- doxytag: member="Passenger::getSignalName" ref="979cb43cef743bf261c329b13e712366" args="(int sig)" -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#979cb43cef743bf261c329b13e712366">getSignalName</a> (int sig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a signal number to its associated name. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#g5d3b342a34d81e7506744e90ee2f9b8b">createUnixServer</a> (const char *filename, unsigned int backlogSize=0, bool autoDelete=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Unix server socket which is bounded to <code>filename</code>.  <a href="group__Support.html#g5d3b342a34d81e7506744e90ee2f9b8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gae3993db9dfa0b05c97b67ccefd2b619">connectToUnixServer</a> (const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a Unix server socket at <code>filename</code>.  <a href="group__Support.html#gae3993db9dfa0b05c97b67ccefd2b619"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Support.html#gaf4965fbefc2dfe26c1380c621962e68">connectToTcpServer</a> (const char *hostname, unsigned int port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a TCP server socket at the given host name and port.  <a href="group__Support.html#gaf4965fbefc2dfe26c1380c621962e68"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">shared_ptr&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Support.html#g41b6c4a82fed72531a147de0505a8396">ptr</a> (T *pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience shortcut for creating a <code>shared_ptr</code>.  <a href="group__Support.html#g41b6c4a82fed72531a147de0505a8396"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Support.html#gf6fab368d70c18fdf16bf5a24f630407">toString</a> (T something)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert anything to a string.  <a href="group__Support.html#gf6fab368d70c18fdf16bf5a24f630407"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">IntType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacePassenger.html#6b2bc9d6fa3848e01fd8c164d30737cc">roundUp</a> (IntType number, IntType multiple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Round <em>number</em> up to the nearest multiple of <em>multiple</em>.  <a href="#6b2bc9d6fa3848e01fd8c164d30737cc"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file provides a bunch of classes for reading and writing messages in the <a class="el" href="classPassenger_1_1MessageChannel.html" title="Convenience class for I/O operations on file descriptors.">MessageChannel</a> format. 
<p>
A random.<p>
Unlike <a class="el" href="classPassenger_1_1MessageChannel.html" title="Convenience class for I/O operations on file descriptors.">MessageChannel</a>, whose operations take control over the I/O handle and may block, these classes are like parsers and data generators. Reader classes require the user to feed data to them. Writer classes generate a bunch of bytes that the user can send out. These classes will never block, making them ideal for use in evented servers.<p>
<h2>Reading messages</h2>
<p>
To read a single message, one must instantiate a reader object and feed network data to it with the feed() method. This method returns the number of bytes actually processed by the reader (i.e. the number of bytes that it has recognized as part of the message).<p>
When the reader has either successfully parsed the data or encountered an error, it will indicate so via the done() method. With hasError() one can check whether an error was encountered or whether the reader succeeded, and with errorCode() one can obtain the exact error reason. Not all readers support hasError() and errorCode() because some readers can never encounter errors and some readers only have a single reason to fail.<p>
When successful, the parsed message can be obtained with value(). This method may only be called when done() is true and there is no error, otherwise the return value is undefined.<p>
At this point, the reader object cannot process any more data and feed() will always return 0. To reuse the object for processing another message, one must reset its state by calling reset().<p>
The following example demonstrates how to read a continuous stream of 32-bit integers: <div class="fragment"><pre class="fragment">   Uint32Reader intReader;
   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
       <span class="comment">// Read a bunch of network data...</span>
       <span class="keywordtype">char</span> buf[1024];
       ssize_t size = recv(fd, buf, <span class="keyword">sizeof</span>(buf));
       <span class="keywordtype">size_t</span> consumed = 0;
       
       <span class="comment">// ...and process it all. We only feed data to the reader that</span>
       <span class="comment">// hasn't already been fed.</span>
       <span class="keywordflow">while</span> (consumed &lt; size) {
           consumed += intReader.feed(buf + consumed, size - consumed);
           <span class="keywordflow">if</span> (intReader.done()) {
               printf(<span class="stringliteral">"Integer: %d\n"</span>, (<span class="keywordtype">int</span>) intReader.value());
               <span class="comment">// The state must be reset before the reader can be reused.</span>
               intReader.reset();
           }
       }
   }
</pre></div><p>
Some readers return non-primitive values in their value() methods, such as <a class="el" href="classPassenger_1_1ArrayReader.html" title="Class for reading a an array message.">ArrayReader</a> and <a class="el" href="classPassenger_1_1ScalarReader.html" title="Class for reading a scalar message.">ScalarReader</a> which return <code>const vector&lt;StaticString&gt; &amp;</code> and <code><a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a></code>, respectively. These values are only valid until either of the following things occur:<p>
<ul>
<li>The buffer containing last the fed data has been destroyed or modified.</li><li>The reader itself has been destroyed.</li></ul>
<p>
This is because the readers try to apply copy-zero optimizations whenever possible. For example, in case of <a class="el" href="classPassenger_1_1ScalarReader.html" title="Class for reading a scalar message.">ScalarReader</a>, it'll check whether the data that has been fed in the first feed() call already contains a full scalar message. If so then it'll just return a <a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a> that points to the scalar message in the fed data; it will not copy the fed data. In this case it is important that the buffer containing the fed data is not modified or destroyed while the <a class="el" href="classPassenger_1_1StaticString.html" title="An immutable, static byte buffer.">StaticString</a> is in use. If the first feed() call does not supply a full scalar message then it will buffer all fed data until the buffer contains a full scalar message, and the result will point to this buffer. Because the buffer is owned by the reader, the result will be invalidated as soon as the reader is destroyed. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="fd60d942a89fbb7f306e330d75704570"></a><!-- doxytag: member="Passenger::AbstractSpawnManagerPtr" ref="fd60d942a89fbb7f306e330d75704570" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1AbstractSpawnManager.html">AbstractSpawnManager</a>&gt; <a class="el" href="namespacePassenger.html#fd60d942a89fbb7f306e330d75704570">Passenger::AbstractSpawnManagerPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient alias for <a class="el" href="classPassenger_1_1AbstractSpawnManager.html" title="Spawning of application processes.">AbstractSpawnManager</a> smart pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="ced1f248465136b313c6dec5fe6ca492"></a><!-- doxytag: member="Passenger::ProcessPtr" ref="ced1f248465136b313c6dec5fe6ca492" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1Process.html">Process</a>&gt; <a class="el" href="namespacePassenger.html#ced1f248465136b313c6dec5fe6ca492">Passenger::ProcessPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient alias for <a class="el" href="classPassenger_1_1Process.html" title="Represents a single application process, as spawned by SpawnManager or by ApplicationPool::Interface...">Process</a> smart pointer. 
<p>

</div>
</div><p>
<a class="anchor" name="6ab2d566ff87a2676c23d8aa40204587"></a><!-- doxytag: member="Passenger::SpawnManagerPtr" ref="6ab2d566ff87a2676c23d8aa40204587" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef shared_ptr&lt;<a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a>&gt; <a class="el" href="namespacePassenger.html#6ab2d566ff87a2676c23d8aa40204587">Passenger::SpawnManagerPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenient alias for <a class="el" href="classPassenger_1_1SpawnManager.html" title="An AbstractSpawnManager implementation.">SpawnManager</a> smart pointer. 
<p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="14174b712df6046cb823cde43d7ef07d"></a><!-- doxytag: member="Passenger::FileType" ref="14174b712df6046cb823cde43d7ef07d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacePassenger.html#14174b712df6046cb823cde43d7ef07d">Passenger::FileType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration which indicates what kind of file a file is. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="14174b712df6046cb823cde43d7ef07d9fc66834fe96c52799397496b8df8486"></a><!-- doxytag: member="FT_NONEXISTANT" ref="14174b712df6046cb823cde43d7ef07d9fc66834fe96c52799397496b8df8486" args="" -->FT_NONEXISTANT</em>&nbsp;</td><td>
The file doesn't exist. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="14174b712df6046cb823cde43d7ef07d1538596a928321d1a282c6bb06e80563"></a><!-- doxytag: member="FT_REGULAR" ref="14174b712df6046cb823cde43d7ef07d1538596a928321d1a282c6bb06e80563" args="" -->FT_REGULAR</em>&nbsp;</td><td>
A regular file or a symlink to a regular file. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="14174b712df6046cb823cde43d7ef07dbb09dbba1071b4770913363db2462eee"></a><!-- doxytag: member="FT_DIRECTORY" ref="14174b712df6046cb823cde43d7ef07dbb09dbba1071b4770913363db2462eee" args="" -->FT_DIRECTORY</em>&nbsp;</td><td>
A directory. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="14174b712df6046cb823cde43d7ef07d3e89b9a7be074975e007d9f7cd77f4ff"></a><!-- doxytag: member="FT_OTHER" ref="14174b712df6046cb823cde43d7ef07d3e89b9a7be074975e007d9f7cd77f4ff" args="" -->FT_OTHER</em>&nbsp;</td><td>
Something else, e.g. 
<p>
a pipe or a socket. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="d88884ee6e2184ef8656fc20f0549b0b"></a><!-- doxytag: member="Passenger::fillInMiddle" ref="d88884ee6e2184ef8656fc20f0549b0b" args="(unsigned int max, const string &amp;prefix, const string &amp;middle, const string &amp;postfix=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Passenger::fillInMiddle           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>postfix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a prefix string, a middle string and a postfix string, try to build a string that looks like <code>prefix + middle + postfix</code>, with as many characters from <code>midle</code> preserved as possible. 
<p>
If <code>prefix + middle + postfix</code> does not fit in <code>max</code> characters, then <code>middle</code> will be truncated so that it fits. If <code>max</code> is too small to contain even 1 character from <code>middle</code>, then an <a class="el" href="classPassenger_1_1ArgumentException.html" title="Indicates that a specified argument is incorrect or violates a requirement.">ArgumentException</a> will be thrown.<p>
<div class="fragment"><pre class="fragment">   <a class="code" href="namespacePassenger.html#d88884ee6e2184ef8656fc20f0549b0b" title="Given a prefix string, a middle string and a postfix string, try to build a string...">fillInMiddle</a>(18, <span class="stringliteral">"server."</span>, <span class="stringliteral">"1234"</span>, <span class="stringliteral">".socket"</span>);    <span class="comment">// "server.1234.socket"</span>
   <a class="code" href="namespacePassenger.html#d88884ee6e2184ef8656fc20f0549b0b" title="Given a prefix string, a middle string and a postfix string, try to build a string...">fillInMiddle</a>(16, <span class="stringliteral">"server."</span>, <span class="stringliteral">"1234"</span>, <span class="stringliteral">".socket"</span>);    <span class="comment">// "server.12.socket"</span>
   <a class="code" href="namespacePassenger.html#d88884ee6e2184ef8656fc20f0549b0b" title="Given a prefix string, a middle string and a postfix string, try to build a string...">fillInMiddle</a>(14, <span class="stringliteral">"server."</span>, <span class="stringliteral">"1234"</span>, <span class="stringliteral">".socket"</span>);    <span class="comment">// ArgumentException</span>
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The resulting string, with <code>middle</code> possibly truncated. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1ArgumentException.html" title="Indicates that a specified argument is incorrect or violates a requirement.">ArgumentException</a></em>&nbsp;</td><td><code>max</code> is too small to contain even 1 character from <code>middle</code>. </td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>result.size() &lt;= max </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d0a66b0e207c46dc6124ff3b2f331e6"></a><!-- doxytag: member="Passenger::getHostName" ref="1d0a66b0e207c46dc6124ff3b2f331e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Passenger::getHostName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the system's host name. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>The host name cannot be retrieved. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="de80218e8b836b796f8b960b6225b439"></a><!-- doxytag: member="Passenger::getProcessUsername" ref="de80218e8b836b796f8b960b6225b439" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Passenger::getProcessUsername           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the username of the user that the current process is running as. 
<p>
If the user has no associated username, then "UID xxxx" is returned, where xxxx is the current UID. 
</div>
</div><p>
<a class="anchor" name="448f25263af0b37b91caee3d294ec4aa"></a><!-- doxytag: member="Passenger::makeDirTree" ref="448f25263af0b37b91caee3d294ec4aa" args="(const string &amp;path, const StaticString &amp;mode=&quot;u=rwx,g=,o=&quot;, uid_t owner=USER_NOT_GIVEN, gid_t group=GROUP_NOT_GIVEN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::makeDirTree           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StaticString &amp;&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>&quot;u=rwx,g=,o=&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&nbsp;</td>
          <td class="paramname"> <em>owner</em> = <code>USER_NOT_GIVEN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&nbsp;</td>
          <td class="paramname"> <em>group</em> = <code>GROUP_NOT_GIVEN</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the directory at the given path, creating intermediate directories if necessary. 
<p>
The created directories' permissions are exactly as specified by the 'mode' parameter (i.e. the umask will be ignored). You can specify this directory's owner and group through the 'owner' and 'group' parameters. A value of USER_NOT_GIVEN for 'owner' and/or GROUP_NOT_GIVEN 'group' means that the owner/group should not be changed.<p>
If 'path' already exists, then nothing will happen.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A mode string, as supported by <a class="el" href="namespacePassenger.html#da53f5a9bdcf3d22d4a710e7ea3678e9" title="Converts a mode string into a mode_t value.">parseModeString()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1FileSystemException.html" title="A filesystem error, as returned by the operating system.">FileSystemException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidModeStringException</em>&nbsp;</td><td>The mode string cannot be parsed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da53f5a9bdcf3d22d4a710e7ea3678e9"></a><!-- doxytag: member="Passenger::parseModeString" ref="da53f5a9bdcf3d22d4a710e7ea3678e9" args="(const StaticString &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mode_t Passenger::parseModeString           </td>
          <td>(</td>
          <td class="paramtype">const StaticString &amp;&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a mode string into a mode_t value. 
<p>
At this time only the symbolic mode strings are supported, e.g. something like looks this: "u=rwx,g=w,o=rx". The grammar is as follows: <div class="fragment"><pre class="fragment">   mode   ::= (clause (<span class="stringliteral">","</span> clause)*)?
   clause ::= who <span class="stringliteral">"="</span> permission*
   who    ::= <span class="stringliteral">"u"</span> | <span class="stringliteral">"g"</span> | <span class="stringliteral">"o"</span>
   permission ::= <span class="stringliteral">"r"</span> | <span class="stringliteral">"w"</span> | <span class="stringliteral">"x"</span> | <span class="stringliteral">"s"</span>
</pre></div><p>
Notes:<ul>
<li>The mode value starts with 0. So if you specify "u=rwx", then the group and world permissions will be empty (set to 0).</li><li>The "s" permission is only allowed for who == "u" or who == "g".</li><li>The return value does not depend on the umask.</li></ul>
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidModeStringException</em>&nbsp;</td><td>The mode string cannot be parsed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="35b11c8ce90e90d01380f182d82f8cac"></a><!-- doxytag: member="Passenger::passenger_bucket_create" ref="35b11c8ce90e90d01380f182d82f8cac" args="(SessionPtr session, PassengerBucketStatePtr state, apr_bucket_alloc_t *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_bucket * Passenger::passenger_bucket_create           </td>
          <td>(</td>
          <td class="paramtype">SessionPtr&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PassengerBucketStatePtr&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_bucket_alloc_t *&nbsp;</td>
          <td class="paramname"> <em>list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
We used to use an apr_bucket_pipe for forwarding the backend process's response to the HTTP client. 
<p>
However, apr_bucket_pipe has a number of issues:<ul>
<li>It closes the pipe's file descriptor when it has reached end-of-stream, but not when an error has occurred. This behavior is undesirable because it can easily cause file descriptor leaks.</li><li>It does weird non-blocking-I/O related things which can cause it to read less data than can actually be read.</li></ul>
<p>
PassengerBucket is like apr_bucket_pipe, but:<ul>
<li>It also holds a reference to a <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a>. When a read error has occured or when end-of-stream has been reached, the <a class="el" href="classPassenger_1_1Session.html" title="Represents a single request/response pair of an application process.">Session</a> will be dereferenced, so that the underlying file descriptor is closed.</li><li>It ignores the APR_NONBLOCK_READ flag because that's known to cause strange I/O problems.</li><li>It can store its current state in a PassengerBucketState data structure. </li></ul>

</div>
</div><p>
<a class="anchor" name="8422d210cbd2f62d21254415b5a7f747"></a><!-- doxytag: member="Passenger::removeDirTree" ref="8422d210cbd2f62d21254415b5a7f747" args="(const string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::removeDirTree           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>path</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an entire directory tree recursively. 
<p>
If the directory doesn't exist then this function does nothing.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1FileSystemException.html" title="A filesystem error, as returned by the operating system.">FileSystemException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b2bc9d6fa3848e01fd8c164d30737cc"></a><!-- doxytag: member="Passenger::roundUp" ref="6b2bc9d6fa3848e01fd8c164d30737cc" args="(IntType number, IntType multiple)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType Passenger::roundUp           </td>
          <td>(</td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>multiple</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round <em>number</em> up to the nearest multiple of <em>multiple</em>. 
<p>

</div>
</div><p>
<a class="anchor" name="8b73dbe534ee6daf755909cf6c321166"></a><!-- doxytag: member="Passenger::toHex" ref="8b73dbe534ee6daf755909cf6c321166" args="(const StaticString &amp;data, char *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::toHex           </td>
          <td>(</td>
          <td class="paramtype">const StaticString &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the given binary data to hexadecimal. 
<p>
This form accepts an output buffer which must be at least data.size() * 2 bytes large. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Mar 28 14:11:58 2010 for Passenger by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
