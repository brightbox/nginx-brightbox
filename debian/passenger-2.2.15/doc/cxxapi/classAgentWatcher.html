<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Passenger: AgentWatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AgentWatcher Class Reference</h1><!-- doxytag: class="AgentWatcher" -->Abstract base class for watching agent processes.  
<a href="#_details">More...</a>
<p>
Inherited by HelperAgentWatcher, and LoggingAgentWatcher.
<p>

<p>
<a href="classAgentWatcher-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a9f83ed13b06ef80d0417f9c313cf61e">sendStartupInfo</a> (<a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a> &amp;channel)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send the started agent process's startup information over the given channel, to the starter process.  <a href="#a9f83ed13b06ef80d0417f9c313cf61e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#982a388ed5c485ab9615c5bc0abbc71e">name</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the agent that this class is watching.  <a href="#982a388ed5c485ab9615c5bc0abbc71e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#daf1c0a7104aea662d90f639066b8247">start</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the agent process.  <a href="#daf1c0a7104aea662d90f639066b8247"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#3da11d23ed3b1210a24844856b7f3159">startWatching</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start watching the agent process.  <a href="#3da11d23ed3b1210a24844856b7f3159"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#e65876d2cc680b739dfee02378233340">forceShutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the agent process to shut down.  <a href="#e65876d2cc680b739dfee02378233340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#b99d4346d7b69d86db1b14206e7caadb">getErrorMessage</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the watcher thread has encountered an error, then the error message will be stored here.  <a href="#b99d4346d7b69d86db1b14206e7caadb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80ef9eaf1a84d994e7ba5f1507616fde"></a><!-- doxytag: member="AgentWatcher::getErrorBacktrace" ref="80ef9eaf1a84d994e7ba5f1507616fde" args="() const " -->
string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#80ef9eaf1a84d994e7ba5f1507616fde">getErrorBacktrace</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error backtrace, if applicable. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#c0749ab103ed5d1adc81b53a7ddc93d8">getFeedbackFd</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the agent process feedback fd, or NULL if the agent process hasn't been started yet.  <a href="#c0749ab103ed5d1adc81b53a7ddc93d8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#77279925d786a774bdf097468c36af96">getExeFilename</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the filename of the agent process's executable.  <a href="#77279925d786a774bdf097468c36af96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#c6325cb940f9c25ef2f44aca00c30755">execProgram</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to exec() the agent with the right arguments.  <a href="#c6325cb940f9c25ef2f44aca00c30755"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#45bc0e41253a0c287e14f708f7dba1e6">sendStartupArguments</a> (pid_t <a class="el" href="classAgentWatcher.html#76de201bbc7111c01c31668211494fa8">pid</a>, <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;fd)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to send startup arguments to the agent process through the given file descriptor, which is the agent process's feedback fd.  <a href="#45bc0e41253a0c287e14f708f7dba1e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#4c1c454374c8916788fee166beacfb05">processStartupInfo</a> (pid_t <a class="el" href="classAgentWatcher.html#76de201bbc7111c01c31668211494fa8">pid</a>, <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;fd, const vector&lt; string &gt; &amp;args)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This method is to process the startup info that the agent process has sent back.  <a href="#4c1c454374c8916788fee166beacfb05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a358a05d41db4ddab9696727849e0d4c">killAndWait</a> (pid_t <a class="el" href="classAgentWatcher.html#76de201bbc7111c01c31668211494fa8">pid</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kill a process with SIGKILL, and attempt to kill its children too.  <a href="#a358a05d41db4ddab9696727849e0d4c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#76de201bbc7111c01c31668211494fa8">pid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">PID of the process we're watching.  <a href="#76de201bbc7111c01c31668211494fa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#c4fa4122858073a1e3e1d96ce2ade6f2">threadExceptionMessage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the watcher thread threw an uncaught exception then its information will be stored here so that the main thread can check whether a watcher encountered an error.  <a href="#c4fa4122858073a1e3e1d96ce2ade6f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#a3eba8fe19117a84764f5f653a03612d">feedbackFd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The agent process's feedback fd.  <a href="#a3eba8fe19117a84764f5f653a03612d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="22ad2ee317c4e254833ab07f377ed7fd"></a><!-- doxytag: member="AgentWatcher::lock" ref="22ad2ee317c4e254833ab07f377ed7fd" args="" -->
boost::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAgentWatcher.html#22ad2ee317c4e254833ab07f377ed7fd">lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock for protecting the exchange of data between the main thread and the watcher thread. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract base class for watching agent processes. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c6325cb940f9c25ef2f44aca00c30755"></a><!-- doxytag: member="AgentWatcher::execProgram" ref="c6325cb940f9c25ef2f44aca00c30755" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::execProgram           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is to exec() the agent with the right arguments. 
<p>
It is called from within a forked child process, so don't do any dynamic memory allocations in here. It must also not throw any exceptions. It must also preserve the value of errno after exec() is called. 
</div>
</div><p>
<a class="anchor" name="e65876d2cc680b739dfee02378233340"></a><!-- doxytag: member="AgentWatcher::forceShutdown" ref="e65876d2cc680b739dfee02378233340" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AgentWatcher::forceShutdown           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Force the agent process to shut down. 
<p>
Returns true if it was shut down, or false if it wasn't started. 
</div>
</div><p>
<a class="anchor" name="b99d4346d7b69d86db1b14206e7caadb"></a><!-- doxytag: member="AgentWatcher::getErrorMessage" ref="b99d4346d7b69d86db1b14206e7caadb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string AgentWatcher::getErrorMessage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the watcher thread has encountered an error, then the error message will be stored here. 
<p>
If the error message is empty then it means everything is still OK. 
</div>
</div><p>
<a class="anchor" name="77279925d786a774bdf097468c36af96"></a><!-- doxytag: member="AgentWatcher::getExeFilename" ref="77279925d786a774bdf097468c36af96" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual string AgentWatcher::getExeFilename           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the filename of the agent process's executable. 
<p>
This method may be called in a forked child process and may therefore not allocate memory. 
</div>
</div><p>
<a class="anchor" name="c0749ab103ed5d1adc81b53a7ddc93d8"></a><!-- doxytag: member="AgentWatcher::getFeedbackFd" ref="c0749ab103ed5d1adc81b53a7ddc93d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> AgentWatcher::getFeedbackFd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the agent process feedback fd, or NULL if the agent process hasn't been started yet. 
<p>
Can be used to check whether this agent process has exited without using waitpid(). 
</div>
</div><p>
<a class="anchor" name="a358a05d41db4ddab9696727849e0d4c"></a><!-- doxytag: member="AgentWatcher::killAndWait" ref="a358a05d41db4ddab9696727849e0d4c" args="(pid_t pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AgentWatcher::killAndWait           </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kill a process with SIGKILL, and attempt to kill its children too. 
<p>
Then wait until it has quit. 
</div>
</div><p>
<a class="anchor" name="982a388ed5c485ab9615c5bc0abbc71e"></a><!-- doxytag: member="AgentWatcher::name" ref="982a388ed5c485ab9615c5bc0abbc71e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* AgentWatcher::name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the agent that this class is watching. 
<p>

</div>
</div><p>
<a class="anchor" name="4c1c454374c8916788fee166beacfb05"></a><!-- doxytag: member="AgentWatcher::processStartupInfo" ref="4c1c454374c8916788fee166beacfb05" args="(pid_t pid, FileDescriptor &amp;fd, const vector&lt; string &gt; &amp;args)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool AgentWatcher::processStartupInfo           </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is to process the startup info that the agent process has sent back. 
<p>
May throw arbitrary exceptions. 
</div>
</div><p>
<a class="anchor" name="45bc0e41253a0c287e14f708f7dba1e6"></a><!-- doxytag: member="AgentWatcher::sendStartupArguments" ref="45bc0e41253a0c287e14f708f7dba1e6" args="(pid_t pid, FileDescriptor &amp;fd)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::sendStartupArguments           </td>
          <td>(</td>
          <td class="paramtype">pid_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is to send startup arguments to the agent process through the given file descriptor, which is the agent process's feedback fd. 
<p>
May throw arbitrary exceptions. 
</div>
</div><p>
<a class="anchor" name="a9f83ed13b06ef80d0417f9c313cf61e"></a><!-- doxytag: member="AgentWatcher::sendStartupInfo" ref="a9f83ed13b06ef80d0417f9c313cf61e" args="(MessageChannel &amp;channel)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::sendStartupInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPassenger_1_1MessageChannel.html">MessageChannel</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>channel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send the started agent process's startup information over the given channel, to the starter process. 
<p>
May throw arbitrary exceptions.<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classAgentWatcher.html#daf1c0a7104aea662d90f639066b8247" title="Starts the agent process.">start()</a> has been called and succeeded. </dd></dl>

</div>
</div><p>
<a class="anchor" name="daf1c0a7104aea662d90f639066b8247"></a><!-- doxytag: member="AgentWatcher::start" ref="daf1c0a7104aea662d90f639066b8247" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pid_t AgentWatcher::start           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the agent process. 
<p>
May throw arbitrary exceptions. 
</div>
</div><p>
<a class="anchor" name="3da11d23ed3b1210a24844856b7f3159"></a><!-- doxytag: member="AgentWatcher::startWatching" ref="3da11d23ed3b1210a24844856b7f3159" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AgentWatcher::startWatching           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start watching the agent process. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd><a class="el" href="classAgentWatcher.html#daf1c0a7104aea662d90f639066b8247" title="Starts the agent process.">start()</a> has been called and succeeded. <p>
This watcher isn't already watching. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RuntimeException</em>&nbsp;</td><td>If a precondition failed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_interrupted</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_resource_error</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="a3eba8fe19117a84764f5f653a03612d"></a><!-- doxytag: member="AgentWatcher::feedbackFd" ref="a3eba8fe19117a84764f5f653a03612d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPassenger_1_1FileDescriptor.html">FileDescriptor</a> <a class="el" href="classAgentWatcher.html#a3eba8fe19117a84764f5f653a03612d">AgentWatcher::feedbackFd</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The agent process's feedback fd. 
<p>

</div>
</div><p>
<a class="anchor" name="76de201bbc7111c01c31668211494fa8"></a><!-- doxytag: member="AgentWatcher::pid" ref="76de201bbc7111c01c31668211494fa8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t <a class="el" href="classAgentWatcher.html#76de201bbc7111c01c31668211494fa8">AgentWatcher::pid</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PID of the process we're watching. 
<p>
0 if no process is started at this time. 
</div>
</div><p>
<a class="anchor" name="c4fa4122858073a1e3e1d96ce2ade6f2"></a><!-- doxytag: member="AgentWatcher::threadExceptionMessage" ref="c4fa4122858073a1e3e1d96ce2ade6f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classAgentWatcher.html#c4fa4122858073a1e3e1d96ce2ade6f2">AgentWatcher::threadExceptionMessage</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the watcher thread threw an uncaught exception then its information will be stored here so that the main thread can check whether a watcher encountered an error. 
<p>
These are empty strings if everything is OK. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>Watchdog.cpp</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Mar 28 14:11:56 2010 for Passenger by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
