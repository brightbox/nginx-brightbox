<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Passenger: Passenger::SpawnManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>Passenger</b>::<a class="el" href="classPassenger_1_1SpawnManager.html">SpawnManager</a>
  </div>
</div>
<div class="contents">
<h1>Passenger::SpawnManager Class Reference<br>
<small>
[<a class="el" href="group__Support.html">Apache-independent support classes and function</a>]</small>
</h1><!-- doxytag: class="Passenger::SpawnManager" -->Spawning of Ruby on Rails/Rack application instances.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="SpawnManager_8h-source.html">SpawnManager.h</a>&gt;</code>
<p>

<p>
<a href="classPassenger_1_1SpawnManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#fdefbbbad39833912ae7f9f106083099">SpawnManager</a> (const string &amp;spawnServerCommand, const string &amp;logFile=&quot;&quot;, const string &amp;rubyCommand=&quot;ruby&quot;, const string &amp;user=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a>.  <a href="#fdefbbbad39833912ae7f9f106083099"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ApplicationPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#af035d564cc4e6683508939c9d6dbb64">spawn</a> (const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;<a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawn a new instance of an application.  <a href="#af035d564cc4e6683508939c9d6dbb64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#2e85c43042b9556ca2fd74b8d28956ce">reload</a> (const string &amp;appRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the cached application instances at the given application root.  <a href="#2e85c43042b9556ca2fd74b8d28956ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1SpawnManager.html#1f77e2e7e6cb464028c13a29f983ad8e">getServerPid</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Process ID of the spawn server.  <a href="#1f77e2e7e6cb464028c13a29f983ad8e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Spawning of Ruby on Rails/Rack application instances. 
<p>
This class is responsible for spawning new instances of Ruby on Rails or Rack applications. Use the <a class="el" href="classPassenger_1_1SpawnManager.html#af035d564cc4e6683508939c9d6dbb64" title="Spawn a new instance of an application.">spawn()</a> method to do so.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This class is fully thread-safe.</dd></dl>
<h2>Implementation details</h2>
<p>
Internally, this class makes use of a spawn server, which is written in Ruby. This server is automatically started when a <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a> instance is created, and automatically shutdown when that instance is destroyed. The existance of the spawn server is almost totally transparent to users of this class. Spawn requests are sent to the server, and details about the spawned process is returned.<p>
If the spawn server dies during the middle of an operation, it will be restarted. See <a class="el" href="classPassenger_1_1SpawnManager.html#af035d564cc4e6683508939c9d6dbb64" title="Spawn a new instance of an application.">spawn()</a> for full details.<p>
The communication channel with the server is anonymous, i.e. no other processes can access the communication channel, so communication is guaranteed to be safe (unless, of course, if the spawn server itself is a trojan).<p>
The server will try to keep the spawning time as small as possible, by keeping corresponding Ruby on Rails frameworks and application code in memory. So the second time an instance of the same application is spawned, the spawn time is significantly lower than the first time. Nevertheless, spawning is a relatively expensive operation (compared to the processing of a typical HTTP request/response), and so should be avoided whenever possible.<p>
See the documentation of the spawn server for full implementation details. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fdefbbbad39833912ae7f9f106083099"></a><!-- doxytag: member="Passenger::SpawnManager::SpawnManager" ref="fdefbbbad39833912ae7f9f106083099" args="(const string &amp;spawnServerCommand, const string &amp;logFile=&quot;&quot;, const string &amp;rubyCommand=&quot;ruby&quot;, const string &amp;user=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Passenger::SpawnManager::SpawnManager           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>spawnServerCommand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>logFile</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>rubyCommand</em> = <code>&quot;ruby&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>user</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spawnServerCommand</em>&nbsp;</td><td>The filename of the spawn server to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>logFile</em>&nbsp;</td><td>Specify a log file that the spawn server should use. Messages on its standard output and standard error channels will be written to this log file. If an empty string is specified, no log file will be used, and the spawn server will use the same standard output/error channels as the current process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rubyCommand</em>&nbsp;</td><td>The Ruby interpreter's command. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>The user that the spawn manager should run as. This parameter only has effect if the current process is running as root. If the empty string is given, or if the <code>user</code> is not a valid username, then the spawn manager will be run as the current user. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>An error occured while trying to setup the spawn server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1IOException.html" title="Represents an error that occured during an I/O operation.">IOException</a></em>&nbsp;</td><td>The specified log file could not be opened. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1f77e2e7e6cb464028c13a29f983ad8e"></a><!-- doxytag: member="Passenger::SpawnManager::getServerPid" ref="1f77e2e7e6cb464028c13a29f983ad8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pid_t Passenger::SpawnManager::getServerPid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Process ID of the spawn server. 
<p>
This method is used in the unit tests and should not be used directly. 
</div>
</div><p>
<a class="anchor" name="2e85c43042b9556ca2fd74b8d28956ce"></a><!-- doxytag: member="Passenger::SpawnManager::reload" ref="2e85c43042b9556ca2fd74b8d28956ce" args="(const string &amp;appRoot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Passenger::SpawnManager::reload           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>appRoot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove the cached application instances at the given application root. 
<p>
<a class="el" href="classPassenger_1_1Application.html" title="Represents a single Ruby on Rails or Rack application instance.">Application</a> code might be cached in memory. But once it a while, it will be necessary to reload the code for an application, such as after deploying a new version of the application. This method makes sure that any cached application code is removed, so that the next time an application instance is spawned, the application code will be freshly loaded into memory.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SystemException.html" title="Represents an error returned by a system call or a standard library call.">SystemException</a></em>&nbsp;</td><td>Unable to communicate with the spawn server, even after a restart. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SpawnException.html" title="Thrown when SpawnManager or ApplicationPool fails to spawn an application instance...">SpawnException</a></em>&nbsp;</td><td>The spawn server died unexpectedly, and a restart was attempted, but it failed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af035d564cc4e6683508939c9d6dbb64"></a><!-- doxytag: member="Passenger::SpawnManager::spawn" ref="af035d564cc4e6683508939c9d6dbb64" args="(const PoolOptions &amp;PoolOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ApplicationPtr Passenger::SpawnManager::spawn           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>PoolOptions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawn a new instance of an application. 
<p>
Spawning details are to be passed via the <code><a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a></code> parameter.<p>
If the spawn server died during the spawning process, then the server will be automatically restarted, and another spawn attempt will be made. If restarting the server fails, or if the second spawn attempt fails, then an exception will be thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a></em>&nbsp;</td><td>An object containing the details for this spawn operation, such as which application to spawn. See <a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a> for details. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer to an <a class="el" href="classPassenger_1_1Application.html" title="Represents a single Ruby on Rails or Rack application instance.">Application</a> object, which represents the application instance that has been spawned. Use this object to communicate with the spawned application. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SpawnException.html" title="Thrown when SpawnManager or ApplicationPool fails to spawn an application instance...">SpawnException</a></em>&nbsp;</td><td>Something went wrong. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boost::thread_interrupted</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SpawnManager_8h-source.html">SpawnManager.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 8 22:35:12 2009 for Passenger by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
