<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Passenger: Passenger::ApplicationPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>Passenger</b>::<a class="el" href="classPassenger_1_1ApplicationPool.html">ApplicationPool</a>
  </div>
</div>
<div class="contents">
<h1>Passenger::ApplicationPool Class Reference<br>
<small>
[<a class="el" href="group__Support.html">Apache-independent support classes and function</a>]</small>
</h1><!-- doxytag: class="Passenger::ApplicationPool" -->A persistent pool of Applications.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ApplicationPool_8h-source.html">ApplicationPool.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Passenger::ApplicationPool:</div>
<div class="dynsection">
<p><center><img src="classPassenger_1_1ApplicationPool__inherit__graph.png" border="0" usemap="#Passenger_1_1ApplicationPool__inherit__map" alt="Inheritance graph"></center>
<map name="Passenger_1_1ApplicationPool__inherit__map">
<area shape="rect" href="classPassenger_1_1StandardApplicationPool.html" title="A standard implementation of ApplicationPool for single&#45;process environments." alt="" coords="5,80,251,107"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPassenger_1_1ApplicationPool-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#c811d261345fcf579f049a2377b4b56b">connected</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> object is still connected to the <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> server.  <a href="#c811d261345fcf579f049a2377b4b56b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPassenger_1_1Application.html#d14f673494991460b16246a527ad8ad9">Application::SessionPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#0b206eb4eb2869423d75c042a0653c67">get</a> (const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;options)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a new session with the application specified by <code><a class="el" href="structPassenger_1_1PoolOptions.html#822039d204b48d9ed49184646734acf3" title="The root directory of the application to spawn.">PoolOptions.appRoot</a></code>.  <a href="#0b206eb4eb2869423d75c042a0653c67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5cc9a7f0c1e7acb9d5815d4420e25ea"></a><!-- doxytag: member="Passenger::ApplicationPool::get" ref="b5cc9a7f0c1e7acb9d5815d4420e25ea" args="(const string &amp;appRoot)" -->
virtual <a class="el" href="classPassenger_1_1Application.html#d14f673494991460b16246a527ad8ad9">Application::SessionPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#b5cc9a7f0c1e7acb9d5815d4420e25ea">get</a> (const string &amp;appRoot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience shortcut for calling <a class="el" href="classPassenger_1_1ApplicationPool.html#0b206eb4eb2869423d75c042a0653c67" title="Open a new session with the application specified by PoolOptions.appRoot.">get()</a> with default spawn options. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#74db4d7a693d45b16320b2296a0c0997">clear</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all application instances that are currently in the pool.  <a href="#74db4d7a693d45b16320b2296a0c0997"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#0e0f21972ab130c9c0f90c2212328794">setMax</a> (unsigned int max)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a hard limit on the number of application instances that this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> may spawn.  <a href="#0e0f21972ab130c9c0f90c2212328794"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#06d1eae044d4d761ce77cf09049df8c8">getActive</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of active applications in the pool.  <a href="#06d1eae044d4d761ce77cf09049df8c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#93b0277beb510855f85fee5de5c369bb">getCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of active applications in the pool.  <a href="#93b0277beb510855f85fee5de5c369bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#b0437434c79b5444ac0faf768f1410e8">setMaxPerApp</a> (unsigned int max)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a hard limit on the number of application instances that a single application may spawn in this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a>.  <a href="#b0437434c79b5444ac0faf768f1410e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPassenger_1_1ApplicationPool.html#d9149c3b434ef8e18fd15a77af1a6c2c">getSpawnServerPid</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the process ID of the spawn server that is used.  <a href="#d9149c3b434ef8e18fd15a77af1a6c2c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A persistent pool of Applications. 
<p>
Spawning application instances, especially Ruby on Rails ones, is a very expensive operation. Despite best efforts to make the operation less expensive (see <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a>), it remains expensive compared to the cost of processing an HTTP request/response. So, in order to solve this, some sort of caching/pooling mechanism will be required. <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> provides this.<p>
Normally, one would use <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a> to spawn a new RoR/Rack application instance, then use <a class="el" href="classPassenger_1_1Application.html#34636f796ff3924ad5ec142aaa581379" title="Connect to this application instance with the purpose of sending a request to the...">Application::connect()</a> to create a new session with that application instance, and then use the returned Session object to send the request and to read the HTTP response. <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> replaces the first step with a call to Application::get(). For example: <div class="fragment"><pre class="fragment">   ApplicationPool pool = some_function_which_creates_an_application_pool();
   
   <span class="comment">// Connect to the application and get the newly opened session.</span>
   <a class="code" href="classPassenger_1_1Application.html#d14f673494991460b16246a527ad8ad9" title="Convenient alias for Session smart pointer.">Application::SessionPtr</a> session(pool-&gt;get(<span class="stringliteral">"/home/webapps/foo"</span>));
   
   <span class="comment">// Send the request headers and request body data.</span>
   session-&gt;sendHeaders(...);
   session-&gt;sendBodyBlock(...);
   <span class="comment">// Done sending data, so we shutdown the writer stream.</span>
   session-&gt;shutdownWriter();

   <span class="comment">// Now read the HTTP response.</span>
   <span class="keywordtype">string</span> responseData = readAllDataFromSocket(session-&gt;getStream());
   <span class="comment">// Done reading data, so we shutdown the reader stream.</span>
   session-&gt;shutdownReader();

   <span class="comment">// This session has now finished, so we close the session by resetting</span>
   <span class="comment">// the smart pointer to NULL (thereby destroying the Session object).</span>
   session.reset();

   <span class="comment">// We can connect to an Application multiple times. Just make sure</span>
   <span class="comment">// the previous session is closed.</span>
   session = app-&gt;connect(<span class="stringliteral">"/home/webapps/bar"</span>)
</pre></div><p>
Internally, <a class="el" href="classPassenger_1_1ApplicationPool.html#0b206eb4eb2869423d75c042a0653c67" title="Open a new session with the application specified by PoolOptions.appRoot.">ApplicationPool::get()</a> will keep spawned applications instances in memory, and reuse them if possible. It wil* <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>try to keep spawning to a minimum. Furthermore, if an application instance hasn't been used for a while, it will be automatically shutdown in order to save memory. Restart requests are honored: if an application has the file 'restart.txt' in its 'tmp' folder, then <a class="el" href="classPassenger_1_1ApplicationPool.html#0b206eb4eb2869423d75c042a0653c67" title="Open a new session with the application specified by PoolOptions.appRoot.">get()</a> will shutdown existing instances of that application and spawn a new instance (this is useful when a new version of an application has been deployed). And finally, one can set a hard limit on the maximum number of applications instances that may be spawned (see <a class="el" href="classPassenger_1_1ApplicationPool.html#0e0f21972ab130c9c0f90c2212328794" title="Set a hard limit on the number of application instances that this ApplicationPool...">ApplicationPool::setMax()</a>).</td></tr>
  </table>
</dl>
Note that <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> is just an interface (i.e. a pure virtual class). For concrete classes, see <a class="el" href="classPassenger_1_1StandardApplicationPool.html" title="A standard implementation of ApplicationPool for single-process environments.">StandardApplicationPool</a> and <a class="el" href="classPassenger_1_1ApplicationPoolServer.html" title="Multi-process usage support for ApplicationPool.">ApplicationPoolServer</a>. The exact pooling algorithm depends on the implementation class. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="74db4d7a693d45b16320b2296a0c0997"></a><!-- doxytag: member="Passenger::ApplicationPool::clear" ref="74db4d7a693d45b16320b2296a0c0997" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::ApplicationPool::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear all application instances that are currently in the pool. 
<p>
This method is used by unit tests to verify that the implementation is correct, and thus should not be called directly. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#bcf8faeb4f431ae07ea0e20270661d08">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="c811d261345fcf579f049a2377b4b56b"></a><!-- doxytag: member="Passenger::ApplicationPool::connected" ref="c811d261345fcf579f049a2377b4b56b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Passenger::ApplicationPool::connected           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> object is still connected to the <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> server. 
<p>
If that's not the case, then one should reconnect to the <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> server.<p>
This method is only meaningful for instances of type ApplicationPoolServer::Client. The default implementation always returns true. 
</div>
</div><p>
<a class="anchor" name="0b206eb4eb2869423d75c042a0653c67"></a><!-- doxytag: member="Passenger::ApplicationPool::get" ref="0b206eb4eb2869423d75c042a0653c67" args="(const PoolOptions &amp;options)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPassenger_1_1Application.html#d14f673494991460b16246a527ad8ad9">Application::SessionPtr</a> Passenger::ApplicationPool::get           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPassenger_1_1PoolOptions.html">PoolOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a new session with the application specified by <code><a class="el" href="structPassenger_1_1PoolOptions.html#822039d204b48d9ed49184646734acf3" title="The root directory of the application to spawn.">PoolOptions.appRoot</a></code>. 
<p>
See the class description for <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a>, as well as <a class="el" href="classPassenger_1_1Application.html#34636f796ff3924ad5ec142aaa581379" title="Connect to this application instance with the purpose of sending a request to the...">Application::connect()</a>, on how to use the returned session object.<p>
Internally, this method may either spawn a new application instance, or use an existing one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>An object containing information on which application to open a session with, as well as spawning details. Spawning details will be used if the pool decides that spawning a new application instance is necessary. See <a class="el" href="classPassenger_1_1SpawnManager.html" title="Spawning of Ruby on Rails/Rack application instances.">SpawnManager</a> and <a class="el" href="structPassenger_1_1PoolOptions.html" title="This struct encapsulates information for ApplicationPool::get() and for SpawnManager::spawn()...">PoolOptions</a> for details. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A session object. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1SpawnException.html" title="Thrown when SpawnManager or ApplicationPool fails to spawn an application instance...">SpawnException</a></em>&nbsp;</td><td>An attempt was made to spawn a new application instance, but that attempt failed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1BusyException.html" title="The application pool is too busy and cannot fulfill a get() request.">BusyException</a></em>&nbsp;</td><td>The application pool is too busy right now, and cannot satisfy the request. One should either abort, or try again later. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classPassenger_1_1IOException.html" title="Represents an error that occured during an I/O operation.">IOException</a></em>&nbsp;</td><td>Something else went wrong. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thread_interrupted</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Applications are uniquely identified with the application root string. So although <code>appRoot</code> does not have to be absolute, it should be. If one calls <code>get("/home/foo")</code> and <code>get("/home/../home/foo")</code>, then <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> will think they're 2 different applications, and thus will spawn 2 application instances. </dd></dl>

<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#ffc8f3ef8b1d925d203794d191d7fef4">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="06d1eae044d4d761ce77cf09049df8c8"></a><!-- doxytag: member="Passenger::ApplicationPool::getActive" ref="06d1eae044d4d761ce77cf09049df8c8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Passenger::ApplicationPool::getActive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of active applications in the pool. 
<p>
This method exposes an implementation detail of the underlying pooling algorithm. It is used by unit tests to verify that the implementation is correct, and thus should not be called directly. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#7773c4a3dfbd88eac72401d063831788">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="93b0277beb510855f85fee5de5c369bb"></a><!-- doxytag: member="Passenger::ApplicationPool::getCount" ref="93b0277beb510855f85fee5de5c369bb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Passenger::ApplicationPool::getCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of active applications in the pool. 
<p>
This method exposes an implementation detail of the underlying pooling algorithm. It is used by unit tests to verify that the implementation is correct, and thus should not be called directly. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#cdbfe2b9ffacdab4438c879c2411bf02">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="d9149c3b434ef8e18fd15a77af1a6c2c"></a><!-- doxytag: member="Passenger::ApplicationPool::getSpawnServerPid" ref="d9149c3b434ef8e18fd15a77af1a6c2c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pid_t Passenger::ApplicationPool::getSpawnServerPid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the process ID of the spawn server that is used. 
<p>
This method exposes an implementation detail. It is used by unit tests to verify that the implementation is correct, and thus should not be used directly. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#6955152d237920988d20297d2fff5660">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="0e0f21972ab130c9c0f90c2212328794"></a><!-- doxytag: member="Passenger::ApplicationPool::setMax" ref="0e0f21972ab130c9c0f90c2212328794" args="(unsigned int max)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::ApplicationPool::setMax           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>max</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a hard limit on the number of application instances that this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a> may spawn. 
<p>
The exact behavior depends on the used algorithm, and is not specified by these API docs.<p>
It is allowed to set a limit lower than the current number of spawned applications. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#04ef8c92da189520ad2022f4f82e9553">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<a class="anchor" name="b0437434c79b5444ac0faf768f1410e8"></a><!-- doxytag: member="Passenger::ApplicationPool::setMaxPerApp" ref="b0437434c79b5444ac0faf768f1410e8" args="(unsigned int max)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Passenger::ApplicationPool::setMaxPerApp           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>max</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a hard limit on the number of application instances that a single application may spawn in this <a class="el" href="classPassenger_1_1ApplicationPool.html" title="A persistent pool of Applications.">ApplicationPool</a>. 
<p>
The exact behavior depends on the used algorithm, and is not specified by these API docs.<p>
It is allowed to set a limit lower than the current number of spawned applications. 
<p>Implemented in <a class="el" href="classPassenger_1_1StandardApplicationPool.html#3bafcda8d880f70561ad8a9da16e26ef">Passenger::StandardApplicationPool</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ApplicationPool_8h-source.html">ApplicationPool.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Apr 8 22:35:12 2009 for Passenger by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
